import {
  CopyShader
} from "./chunk-2KW7E7JN.js";
import {
  Pass
} from "./chunk-R26BO5GJ.js";
import {
  AdditiveBlending,
  LinearFilter,
  RGBAFormat,
  ShaderMaterial,
  UniformsUtils,
  Vector2,
  WebGLRenderTarget
} from "./chunk-T54TFPEI.js";

// node_modules/three/examples/jsm/shaders/ConvolutionShader.js
var ConvolutionShader = {
  defines: {
    "KERNEL_SIZE_FLOAT": "25.0",
    "KERNEL_SIZE_INT": "25"
  },
  uniforms: {
    "tDiffuse": { value: null },
    "uImageIncrement": { value: new Vector2(1953125e-9, 0) },
    "cKernel": { value: [] }
  },
  vertexShader: [
    "uniform vec2 uImageIncrement;",
    "varying vec2 vUv;",
    "void main() {",
    "	vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;",
    "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}"
  ].join("\n"),
  fragmentShader: [
    "uniform float cKernel[ KERNEL_SIZE_INT ];",
    "uniform sampler2D tDiffuse;",
    "uniform vec2 uImageIncrement;",
    "varying vec2 vUv;",
    "void main() {",
    "	vec2 imageCoord = vUv;",
    "	vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );",
    "	for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {",
    "		sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];",
    "		imageCoord += uImageIncrement;",
    "	}",
    "	gl_FragColor = sum;",
    "}"
  ].join("\n"),
  buildKernel: function(sigma) {
    function gauss(x, sigma2) {
      return Math.exp(-(x * x) / (2 * sigma2 * sigma2));
    }
    var i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil(sigma * 3) + 1;
    if (kernelSize > kMaxKernelSize)
      kernelSize = kMaxKernelSize;
    halfWidth = (kernelSize - 1) * 0.5;
    values = new Array(kernelSize);
    sum = 0;
    for (i = 0; i < kernelSize; ++i) {
      values[i] = gauss(i - halfWidth, sigma);
      sum += values[i];
    }
    for (i = 0; i < kernelSize; ++i)
      values[i] /= sum;
    return values;
  }
};

// node_modules/three/examples/jsm/postprocessing/BloomPass.js
var BloomPass = function(strength, kernelSize, sigma, resolution) {
  Pass.call(this);
  strength = strength !== void 0 ? strength : 1;
  kernelSize = kernelSize !== void 0 ? kernelSize : 25;
  sigma = sigma !== void 0 ? sigma : 4;
  resolution = resolution !== void 0 ? resolution : 256;
  var pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
  this.renderTargetX = new WebGLRenderTarget(resolution, resolution, pars);
  this.renderTargetX.texture.name = "BloomPass.x";
  this.renderTargetY = new WebGLRenderTarget(resolution, resolution, pars);
  this.renderTargetY.texture.name = "BloomPass.y";
  if (CopyShader === void 0)
    console.error("THREE.BloomPass relies on CopyShader");
  var copyShader = CopyShader;
  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
  this.copyUniforms["opacity"].value = strength;
  this.materialCopy = new ShaderMaterial({
    uniforms: this.copyUniforms,
    vertexShader: copyShader.vertexShader,
    fragmentShader: copyShader.fragmentShader,
    blending: AdditiveBlending,
    transparent: true
  });
  if (ConvolutionShader === void 0)
    console.error("THREE.BloomPass relies on ConvolutionShader");
  var convolutionShader = ConvolutionShader;
  this.convolutionUniforms = UniformsUtils.clone(convolutionShader.uniforms);
  this.convolutionUniforms["uImageIncrement"].value = BloomPass.blurX;
  this.convolutionUniforms["cKernel"].value = ConvolutionShader.buildKernel(sigma);
  this.materialConvolution = new ShaderMaterial({
    uniforms: this.convolutionUniforms,
    vertexShader: convolutionShader.vertexShader,
    fragmentShader: convolutionShader.fragmentShader,
    defines: {
      "KERNEL_SIZE_FLOAT": kernelSize.toFixed(1),
      "KERNEL_SIZE_INT": kernelSize.toFixed(0)
    }
  });
  this.needsSwap = false;
  this.fsQuad = new Pass.FullScreenQuad(null);
};
BloomPass.prototype = Object.assign(Object.create(Pass.prototype), {
  constructor: BloomPass,
  render: function(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    if (maskActive)
      renderer.state.buffers.stencil.setTest(false);
    this.fsQuad.material = this.materialConvolution;
    this.convolutionUniforms["tDiffuse"].value = readBuffer.texture;
    this.convolutionUniforms["uImageIncrement"].value = BloomPass.blurX;
    renderer.setRenderTarget(this.renderTargetX);
    renderer.clear();
    this.fsQuad.render(renderer);
    this.convolutionUniforms["tDiffuse"].value = this.renderTargetX.texture;
    this.convolutionUniforms["uImageIncrement"].value = BloomPass.blurY;
    renderer.setRenderTarget(this.renderTargetY);
    renderer.clear();
    this.fsQuad.render(renderer);
    this.fsQuad.material = this.materialCopy;
    this.copyUniforms["tDiffuse"].value = this.renderTargetY.texture;
    if (maskActive)
      renderer.state.buffers.stencil.setTest(true);
    renderer.setRenderTarget(readBuffer);
    if (this.clear)
      renderer.clear();
    this.fsQuad.render(renderer);
  }
});
BloomPass.blurX = new Vector2(1953125e-9, 0);
BloomPass.blurY = new Vector2(0, 1953125e-9);
export {
  BloomPass
};
//# sourceMappingURL=three_examples_jsm_postprocessing_BloomPass.js.map
