import {
  CopyShader
} from "./chunk-2KW7E7JN.js";
import {
  Pass
} from "./chunk-R26BO5GJ.js";
import {
  Clock,
  LinearFilter,
  Mesh,
  OrthographicCamera,
  PlaneBufferGeometry,
  RGBAFormat,
  ShaderMaterial,
  UniformsUtils,
  Vector2,
  WebGLRenderTarget
} from "./chunk-T54TFPEI.js";
import "./chunk-2B2CG5KL.js";

// node_modules/three/examples/jsm/postprocessing/ShaderPass.js
var ShaderPass = function(shader, textureID) {
  Pass.call(this);
  this.textureID = textureID !== void 0 ? textureID : "tDiffuse";
  if (shader instanceof ShaderMaterial) {
    this.uniforms = shader.uniforms;
    this.material = shader;
  } else if (shader) {
    this.uniforms = UniformsUtils.clone(shader.uniforms);
    this.material = new ShaderMaterial({
      defines: Object.assign({}, shader.defines),
      uniforms: this.uniforms,
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader
    });
  }
  this.fsQuad = new Pass.FullScreenQuad(this.material);
};
ShaderPass.prototype = Object.assign(Object.create(Pass.prototype), {
  constructor: ShaderPass,
  render: function(renderer, writeBuffer, readBuffer) {
    if (this.uniforms[this.textureID]) {
      this.uniforms[this.textureID].value = readBuffer.texture;
    }
    this.fsQuad.material = this.material;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this.fsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear)
        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      this.fsQuad.render(renderer);
    }
  }
});

// node_modules/three/examples/jsm/postprocessing/MaskPass.js
var MaskPass = function(scene, camera) {
  Pass.call(this);
  this.scene = scene;
  this.camera = camera;
  this.clear = true;
  this.needsSwap = false;
  this.inverse = false;
};
MaskPass.prototype = Object.assign(Object.create(Pass.prototype), {
  constructor: MaskPass,
  render: function(renderer, writeBuffer, readBuffer) {
    var context = renderer.getContext();
    var state = renderer.state;
    state.buffers.color.setMask(false);
    state.buffers.depth.setMask(false);
    state.buffers.color.setLocked(true);
    state.buffers.depth.setLocked(true);
    var writeValue, clearValue;
    if (this.inverse) {
      writeValue = 0;
      clearValue = 1;
    } else {
      writeValue = 1;
      clearValue = 0;
    }
    state.buffers.stencil.setTest(true);
    state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
    state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 4294967295);
    state.buffers.stencil.setClear(clearValue);
    state.buffers.stencil.setLocked(true);
    renderer.setRenderTarget(readBuffer);
    if (this.clear)
      renderer.clear();
    renderer.render(this.scene, this.camera);
    renderer.setRenderTarget(writeBuffer);
    if (this.clear)
      renderer.clear();
    renderer.render(this.scene, this.camera);
    state.buffers.color.setLocked(false);
    state.buffers.depth.setLocked(false);
    state.buffers.stencil.setLocked(false);
    state.buffers.stencil.setFunc(context.EQUAL, 1, 4294967295);
    state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
    state.buffers.stencil.setLocked(true);
  }
});
var ClearMaskPass = function() {
  Pass.call(this);
  this.needsSwap = false;
};
ClearMaskPass.prototype = Object.create(Pass.prototype);
Object.assign(ClearMaskPass.prototype, {
  render: function(renderer) {
    renderer.state.buffers.stencil.setLocked(false);
    renderer.state.buffers.stencil.setTest(false);
  }
});

// node_modules/three/examples/jsm/postprocessing/EffectComposer.js
var EffectComposer = function(renderer, renderTarget) {
  this.renderer = renderer;
  if (renderTarget === void 0) {
    var parameters = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBAFormat
    };
    var size = renderer.getSize(new Vector2());
    this._pixelRatio = renderer.getPixelRatio();
    this._width = size.width;
    this._height = size.height;
    renderTarget = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, parameters);
    renderTarget.texture.name = "EffectComposer.rt1";
  } else {
    this._pixelRatio = 1;
    this._width = renderTarget.width;
    this._height = renderTarget.height;
  }
  this.renderTarget1 = renderTarget;
  this.renderTarget2 = renderTarget.clone();
  this.renderTarget2.texture.name = "EffectComposer.rt2";
  this.writeBuffer = this.renderTarget1;
  this.readBuffer = this.renderTarget2;
  this.renderToScreen = true;
  this.passes = [];
  if (CopyShader === void 0) {
    console.error("THREE.EffectComposer relies on CopyShader");
  }
  if (ShaderPass === void 0) {
    console.error("THREE.EffectComposer relies on ShaderPass");
  }
  this.copyPass = new ShaderPass(CopyShader);
  this.clock = new Clock();
};
Object.assign(EffectComposer.prototype, {
  swapBuffers: function() {
    var tmp = this.readBuffer;
    this.readBuffer = this.writeBuffer;
    this.writeBuffer = tmp;
  },
  addPass: function(pass) {
    this.passes.push(pass);
    pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  },
  insertPass: function(pass, index) {
    this.passes.splice(index, 0, pass);
    pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  },
  removePass: function(pass) {
    const index = this.passes.indexOf(pass);
    if (index !== -1) {
      this.passes.splice(index, 1);
    }
  },
  isLastEnabledPass: function(passIndex) {
    for (var i = passIndex + 1; i < this.passes.length; i++) {
      if (this.passes[i].enabled) {
        return false;
      }
    }
    return true;
  },
  render: function(deltaTime) {
    if (deltaTime === void 0) {
      deltaTime = this.clock.getDelta();
    }
    var currentRenderTarget = this.renderer.getRenderTarget();
    var maskActive = false;
    var pass, i, il = this.passes.length;
    for (i = 0; i < il; i++) {
      pass = this.passes[i];
      if (pass.enabled === false)
        continue;
      pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
      pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
      if (pass.needsSwap) {
        if (maskActive) {
          var context = this.renderer.getContext();
          var stencil = this.renderer.state.buffers.stencil;
          stencil.setFunc(context.NOTEQUAL, 1, 4294967295);
          this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);
          stencil.setFunc(context.EQUAL, 1, 4294967295);
        }
        this.swapBuffers();
      }
      if (MaskPass !== void 0) {
        if (pass instanceof MaskPass) {
          maskActive = true;
        } else if (pass instanceof ClearMaskPass) {
          maskActive = false;
        }
      }
    }
    this.renderer.setRenderTarget(currentRenderTarget);
  },
  reset: function(renderTarget) {
    if (renderTarget === void 0) {
      var size = this.renderer.getSize(new Vector2());
      this._pixelRatio = this.renderer.getPixelRatio();
      this._width = size.width;
      this._height = size.height;
      renderTarget = this.renderTarget1.clone();
      renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose();
    this.renderTarget2.dispose();
    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
  },
  setSize: function(width, height) {
    this._width = width;
    this._height = height;
    var effectiveWidth = this._width * this._pixelRatio;
    var effectiveHeight = this._height * this._pixelRatio;
    this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
    this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
    for (var i = 0; i < this.passes.length; i++) {
      this.passes[i].setSize(effectiveWidth, effectiveHeight);
    }
  },
  setPixelRatio: function(pixelRatio) {
    this._pixelRatio = pixelRatio;
    this.setSize(this._width, this._height);
  }
});
var Pass2 = function() {
  this.enabled = true;
  this.needsSwap = true;
  this.clear = false;
  this.renderToScreen = false;
};
Object.assign(Pass2.prototype, {
  setSize: function() {
  },
  render: function() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
});
Pass2.FullScreenQuad = function() {
  var camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
  var geometry = new PlaneBufferGeometry(2, 2);
  var FullScreenQuad = function(material) {
    this._mesh = new Mesh(geometry, material);
  };
  Object.defineProperty(FullScreenQuad.prototype, "material", {
    get: function() {
      return this._mesh.material;
    },
    set: function(value) {
      this._mesh.material = value;
    }
  });
  Object.assign(FullScreenQuad.prototype, {
    dispose: function() {
      this._mesh.geometry.dispose();
    },
    render: function(renderer) {
      renderer.render(this._mesh, camera);
    }
  });
  return FullScreenQuad;
}();
export {
  EffectComposer,
  Pass2 as Pass
};
//# sourceMappingURL=three_examples_jsm_postprocessing_EffectComposer__js.js.map
